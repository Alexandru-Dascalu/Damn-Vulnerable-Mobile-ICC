<resources>
    <string name="app_name">Damn Vulnerable Mobile ICC</string>

    <!--Strings for the Introduction fragment-->
    <string name="welcome_msg">Welcome to DVM-ICC!</string>
    <string name="introductionHeading">Introduction</string>
    <string name="introductionText">
        Damn Vulnerable Mobile -  Inter Component Communication is an intentionally insecure
        Android image, created to be an educational tool to teach people about cyberattacks and
        vulnerabilities related to Inter Component Communication (ICC) in Android.

        \n\nThis educational tool is aimed at penetration testers, app developers and tech savvy
        people alike. It has four different operation modes that can be used to complete
        challenges, tailored to users with more or less experience.

        \n\nIndividual vulnerabilities are explored through challenges. Each challenge
        consists of an authentic scenario of a malware attacking a vulnerable application. You
        have to identify the malware and vulnerable apps, then start the apps and use the malware
        to perform an attack and observe its effects.

        \n\nDepending on the user mode, you will benefit from an explanation of the vulnerability,
        how to identify it and of various ways to fix it. You are able to see the attack happen
        and you have to answer various questions to complete the challenge.
    </string>
    <string name="whyICCHeading">Importance of ICC</string>
    <string name="whyICCText">
        We chose to explore Inter Component Communication vulnerabilities on Android in this project
        due to the current state of mobile application security.

        \n\nFirstly, insecure inter-component communication is a high-risk vulnerability, and it is
        more dangerous than insecure storage, insecure transmission of data, inadequate brute force
        protection or other common vulnerabilities, according to this
        <a href="https://www.ptsecurity.com/upload/corporate/ww-en/analytics/Mobile-Application-Vulnerabilities-and-Threats-2019-eng.pdf">2019 report</a>.

        \n\nSecondly, this type of vulnerability is relatively common. It can be found in 29
        percent of mobile apps according, and the average Android application has 1.1 ICC
        vulnerabilities. according the report linked above.

        \n\nThirdly, while the overwhelming majority of vulnerabilities of other types are
        introduced in apps through the use of third-party libraries and rarely through developer
        code, ICC vulnerabilities are different. According to <a href ="https://ieeexplore.ieee.org/abstract/document/8936901">this paper</a>
        , between a third and a half of ICC vulnerabilities come from developer code. Therefore,
        education about ICC vulnerabilities addressed to developers would lead to less
        vulnerabilities of this type.

        \n\nFourthly, ICC vulnerabilities are not showcased in detail in real word projects
        similar to this one. Damn Vulnerable Web Application does not cover any Inter Process
        vulnerabilities and TryHackMe.com has no dedicated activities on this topic. Damn Insecure
        and Vulnerable App has 2 challenges that exploit badly implemented communication
        between components. However, they do not show in detail all the possible ICC vulnerabilities
        and threats.
    </string>
    <string name="workflowHeading">Workflow</string>
    <string name="workflowText">
        This section explains the intended workflow for this software.

        \n\nIn the Info view, accessed through the bottom bar, you have all of the necessary
        technical background in order to use this software. It explains Android Security, what
        Android Components are, how permissions work in Android, how Inter Component Communication
        is done in Android, and finally the two main categories of ICC related attacks explored by this
        project.

        \n\nAfter you have understood the necessary information, you can go to the Challenges view,
        through which you can access the various challenges. Each challenge is an authentic scenario
        of a variation of the two main types of attacks, involving a malicious app and a
        vulnerable target app. Different challenges involve attacks that
        may target different types of components, or that have a different effect. Click on the
        button of each challenge to start it.

        \n\nThere are four different modes in which you can complete a challenge.

        \n\nFor each challenge, there are various security levels, which change how vulnerable the
        target app is and how hard it is for the malware to perform the attack. You can change the level
        from inside each challenge. The number of security levels and what they mean varies depending
        on the challenge. One security level will be Impossible, for which the attack is no longer
        possible.

        \n\nThe beginner mode gives you a full explanation of the attack. After you have read it,
        you then need to look at a list of all the manifests and some code snippets of all
        apps of this project. Based on the explanation of the attack you were given and the code
        snippets you see, you then have to
        identify the malicious app and the vulnerable app. There is another view which displays
        questions to help guide you through the challenge. Here, you can submit your answers and
        find out if you have correctly identified the apps. You may be able to access hints if you
        keep getting the answer wrong.

        \n\nThen, you need to start the vulnerable and malware apps in order to perform the attack
        or watch it happen in real time. The exact way this happens will vary depending on the
        challenge. Watching or performing the attack will usually uncover some secret which you can
        then submit to the Questions view in order to complete the challenge, showing that you have
        penetrated the vulnerable application. This view may contain other questions to test your
        knowledge. When completing the challenge, you are given an explanation about how the attack
        in the challenge worked, why the scenario was authentic and how the different security
        levels fix the vulnerability.

        \n\nThe expert mode is just like beginner mode, only that it does not offer access to the
        detailed explanation of the attack.

        \n\nThe beginner and expert modes can be used on a mobile device, you do not need a computer
        or any developer tools.

        \n\nThe Make your own Malware mode disables the included malware for that challenge, so that
        you can create your own malware app to attack the challenge\'s vulnerable app. This mode will
        also let you access the full explanation of the attack and the manifest and relevant code of
        the victim app. This mode is meant to be completed using a computer and Android Studio. You
        will need to clone the repository of this project.

        \n\nThe Fix Vulnerable App mode allows you to fix a vulnerable app yourself. For each
        challenge, there is a second vulnerable application. Since in the Beginner or Expert mode,
        you are shown code for fixing the first vulnerable app, in this mode you can fix the second
        vulnerable app without being shown the code. The malware may be able to detect if it has
        been defeated and let you know. This mode gives you access to the full
        explanation of the attack and of the various security levels. You will need a computer and
        Android Studio for this mode, and you need to clone the repository of this project.

        \n\nThe Make your own Malware and Fix Vulnerable App modes are only accessible once you have
        completed the Beginner or Expert modes.
    </string>

    <!--Strings for the information fragment-->
    <string name="informationTitle">Information</string>
    <string name="androidFundamentalsHeader">Android Security Fundamentals</string>
    <string name="androidFundamentals">
        In Android, each application is assigned a unique user ID known only by the OS. The files
        of an app can only be accessed by a user with the same ID as that of the app. Moreover,
        each app runs in its own process by default, and each process runs in its own virtual
        machine. Therefore, each Android app has its own sandbox, which
        enhances the security of the system, as apps are separated from each other.
    </string>
    <string name="apiLevelsHeader">API Levels</string>
    <string name="apiLevels">
        Code written by mobile app developers can interact with the Android system through its
        Application Programming Interface, or API. This API is made up of various packages, classes
        and XML elements that are used to define UI elements, access system resources, define
        application security, and more.

        \n\nThroughout the development of Android,
        the API is modified to introduce new features and improve security or performance. Therefore,
        in order to identify each incremental version of the API, a unique integer is assigned to
        each version or level. This level is independent of the version of the Android release, as
        the API level is solely concerned with modifications in the API and not backend code.

        \n\nHowever, in practice, each Android release usually comes with a new API level. Over the
        years, there have been changes to the API that improved software security, and therefore
        some vulnerabilities are harder or impossible to exploit in current API levels.

        \n\nThe suite of apps developed as part of this project are designed to run on API 25, or
        Android 7.1. They can still run on newer devices, but some vulnerabilities, particularly
        broadcast theft and broadcast injection, are limited on Android 8 and newer.
    </string>
    <string name="androidComponentsHeader">Android Components</string>
    <string name="androidComponents">
        Android mobile applications are made up of logical building blocks called components. In
        Android, a component is an entity which allows the user or the operating system to access
        the application. Therefore, a component does not necessarily correlate
        with other computing concepts such as processes, threads, and classes. When any component
        of an app needs to be run, the system starts a process for that app.

        \n\nThere are four types of components in Android: activities, services, broadcast receivers
        and content providers.
    </string>
    <string name="androidManifestHeading">Android Manifest</string>
    <string name="androidManifestText">
        The manifest of an Android application is an XML file that gives the OS information
        about the app’s structure, capabilities and needs. All Android app components, except
        broadcast receivers, need to be declared in the manifest file, and for each component you
        can define permission requirements and the capabilities of the component.

        \n\nMoreover, the developer must say in the manifest file what hardware or software system
        features the app uses, whether those features are required, and what is the minimum API
        level that the app can run on. For example, an app would not be installed on a device if
        the app’s manifest said it required a microphone and the mobile device did not have
        a microphone.
    </string>
    <string name="activitiesHeading">Activities</string>
    <string name="activitiesText">
        Activities represent the individual app UI screens through which you interact with the app.
        For example, a news aggregator application might have an activity for viewing a list of
        news articles and another for changing the app’s notification settings.

        \n\nActivities are used by the operating system to keep track of what the you see on screen,
        of what information you are interested in, and of minimized apps.

        \n\nActivities are independent components and therefore it is possible that activities of
        different apps collaborate. This is what happens in a browser when you want to share
        a link and you have to choose between various messaging applications.
    </string>
    <string name="servicesHeading">Services</string>
    <string name="servicesText">
        Services are components used for running more long-term operations in the background.
        A service does not represent a separate process or thread, but an interface for the system
        to let the app work in the background. A service does not have a UI by itself.

        \n\nExamples of the usage of services include VPN apps that maintain a VPN connection in
        the background or when WhatsApp performs periodical backups of messages.

        \n\nThere are three types of services: foreground services, which perform tasks that are
        noticeable to the user and must display a notification, background services, which do
        things that are not noticeable by the user, and bound services, which act as servers
        responding to requests made by client components.
    </string>
    <string name="receiverHeading">Broadcast Receivers</string>
    <string name="receiverText">
        Broadcast receivers are components that an app uses to receive system wide broadcasts.
        These broadcasts are messages sent by the operating system or by other apps. Using
        receivers, applications can react to various events. A receiver can
        listen for an event even when the app is not running.

        \n\nFor example, the system can send a broadcast letting apps know that the device’s
        battery is low or that airplane mode has been activated, or an application can send a
        message that the download of a file has finished, and it can be accessed now.

        \n\nUsually, broadcast receivers do a minimal amount of work and simply start other
        components like activities or services to handle the event. Broadcast receivers do not have
        a user interface, but can display notifications. In addition, it is worth noting that they
        do not have to be declared in the manifest file but can be created programmatically as well.

        \n\nThere are three types of broadcasts:
            \n\n• Normal broadcasts – These are sent to all receivers at the same time, and each receiver can react independently of other receivers.
            \n\n• Ordered broadcasts – These are sent to receivers one by one. Unlike normal broadcast,
        the receiver currently processing the broadcast can change what information the broadcast
        contains, and can even cancel the broadcast. Broadcast receivers can be registered with a
        certain priority for getting broadcasts. Receivers with the same priority get broadcasts
        in random order.
            \n\n• Sticky broadcasts – Broadcasts of this type are persistent, as they remain after
        they have been broadcast to all receivers and are re-broadcast to any newly created
        receivers. They have been deprecated since API level 21, because they are very insecure,
        and will not be covered by this project.
    </string>
    <string name="providerHeading">Content Providers</string>
    <string name="providerText">
        Content providers are interfaces through which apps can access data stored in persistent
        storage such as a remote server, an SQLite database or local file storage. A provider can
        be used by components of other apps. Therefore, they are used by the system to manage
        access to shared data. Content providers can restrict access to the data to apps with
        certain permissions and give temporary access to certain files only.
    </string>
    <string name="permissionsHeading">Android Permissions</string>
    <string name="permissionsText">
        Android follows the principle of least privilege. This means that, by default, each app
        only has access to the resources that it needs to complete its job, and cannot perform any
        action that could affect other apps, the OS or the user.

        \n\nThis principle is enforced through a system of permissions, meaning that an application
        can only access sensitive data, system features or components of other applications if it
        possesses the necessary requirements. For instance, an application needs the correct
        permission if it wants to access the user’s contacts or the device’s camera or file system.

        \n\nThe developer can protect the components of an app with permission requirements by
        adding an android:permission tag in the manifest file. These elements can be added once
        for the whole application, or for each component.

        \n\nThere are four types of permissions, based on the level of protection they allow:
            \n\n• Normal permissions – Permissions for access to resources that, if granted, would
                pose a minimal risk to the user, such as the permission to set the time zone.
                They are given automatically.
            \n\n• Dangerous permissions – These permissions are for resources related to private
                user information, or that can affect the state of the system or of other apps.
                The user needs to give these permissions explicitly. Examples include permissions
                to access the camera or the device location.
            \n\n• Signature permissions – These are special permissions, designed for use among a
                group of apps created by the same developer, for purposes specific to those apps.
                An app is automatically granted a signature permission only if it is signed by
                the same certificate as the app that defined the permission. In this case, a
                certificate is a unique identification for the developer of the app, like the
                TLS certificates used to verify the authenticity of websites. The certificate
                can be self-signed by the developer.
            \n\n• Signature or System permissions – a deprecated type of permission since API level
                23. It is automatically granted only if the app is signed by the same certificate
                as the app that declared the permission, or if the app is in the system folder.
                Apps in the system folder are pre-installed by the device’s vendor.

        \n\nApplications have the ability to declare their own permissions. These permissions can
        be used to restrict access to components of an application. This is done by declaring a
        permission in the manifest file of the app. This declaration specifies the permission’s
        full name, a label, a description, and the protection level.

        \n\nExample of a custom permission declaration:
    </string>
    <string name="customPermissionsCode">
        <![CDATA[
        <permission
            \n\tandroid:name=\"uk.swansea.ac.uk.alexandru.
            \n\t\ticc_education.permission.BANKING_ACTIVITY\"
            \n\tandroid:label=\"@string/lab _bankingActivity\"
            \n\tandroid:description=\"@string/desc_bankingActivity\"
            \n\tandroid:protectionLevel=\"dangerous\" />]]>
    </string>
    <string name="iccHeading">Inter Component Communication</string>
    <string name="iccText">
        Each Android application runs in its own sandbox, and by default can not see what other
        applications are doing. Sometimes, we need the system to communicate with the apps, and
        applications can enrich the user\'s experience by collaborating.

        \n\nMoreover, an app component can be used by other apps to provide extra
        functionality. For example, a browser lets you select which social media or messaging app
        to use for sharing a link.

        \n\nIntents are a class in the Android API that are used as messages for communication
        between application components. Intents are used to start new activities, start and stop
        services, bind or unbind a component to a service, and they represent the broadcasts that
        are sent to receivers. They are also used for sending results to the caller of an activity.

        \n\nIntents can specify what component to start, what action the component that sends the
        intent wants to accomplish, data in the form of a URI, the MIME type of the URI, and perhaps
        key value pairs created by the parent component of the intent.

        \n\nBy default, application components are not accessible to outside applications through
        intents. However, a component can be exported and thus receive intents from other
        applications. To export a component, you can set the &lt;exported&gt; tag in a component element
        in the app’s manifest to true. However, if the component has an intent filter defined in
        the manifest, the component will be exported by default, unless the exported tag is
        explicitly set to false. Intent Filters will be fully explained later.

        \n\nFurther complicating things, developers can also configure an application to use the
        same Android User ID as other applications created by them. This means these apps can run
        in the same sandbox and in the same process. Therefore, they can access each other’s
        components regardless of the value of the exported tag or the presence of intent filters.
    </string>
    <string name="explicitIntentsHeading">Explicit Intents</string>
    <string name="explicitIntentsText">
        Explicit intents directly specify the application that should receive the intent. This is
        done by setting either the package name of the receiving application, or the full name of
        a component of said app.

        \n\nMaking an intent to be explicit means that only the targeted app or app component can
        receive the intent. Explicit intents are usually used for communication between components
        of the same app.

        \n\nThe most common usage is when you press a button that leads to the a new
        screen. The activity of the new screen should be started by an explicit intent.
    </string>
    <string name="implicitIntentsHeading">Implicit Intents</string>
    <string name="implicitIntentsText">
        Implicit intents do not directly specify what application or component it should be sent to.
        Instead, the Android system decides who to send it to based on the information in the
        intent and what other components have declared they can handle.

        \n\nTo this end, implicit intents may specify a combination of the action the
        recipient should do, some intent categories, a URI data link, or a MIME data type. All
        of these are optional, and the developer has flexibility in how to define the implicit intent.

        \n\nA component defines what intents it can handle by specifying Intent Filters in the
        manifest file. A filter defines what intents a component can handle. A filter can say
        what actions the component can perform, what intent categories it accepts, the MIME data
        types it accepts or the kind of URI resources it can handle. A component may declare
        multiple Intent Filters, and it is recommended that this is done for each task the
        component can do.

        \n\nWhen an implicit intent is sent, the Android System compares its attributes against all
        intent filters of all components of all apps on the device. For the intent to be matched
        with a filter, three tests are performed: the Action test, the Category test, and the Data
        test.

        \n\nIn order to pass the Action test, the Intent’s action must be amongst the actions of
        the filter. It passes the Category Test if all of its categories are found in the
        filter’s declaration, and the Data Test is passed if the data URI or MIME type of the intent
        matches one of the data elements in the filter.

        \n\nIf the component has multiple filters, the intent only needs to match one of them for
        it to be passed to the component.

        \n\nIf only one intent filter is compatible with the implicit intent, the operating system
        will start that filter’s component. However, if there are multiple matches, a dialog will
        be displayed to the user so they can manually select the app to handle the intent.

        \n\nFor example, if there are multiple browsers installed on the mobile device, and within
        an app the user clicks on a web link, they will then see a dialog letting them
        choose what browser to use to open that page. This is because the parent app sent an
        implicit intent, and all browsers had filters that matched with the intent.

        Below you can see Kotlin code for making an implicit intent for opening a web link.
    </string>
    <string name="implicitIntentCode">
        val intent : Intent = Intent(Intent.ACTION_VIEW,
                \n\t\tURI.parse(\"https://www.pexels.com/\"))
        \nstartActivity(intent)
    </string>
    <string name="intentFilterExplanationText">
        An example of an intent filter to match for web link intents such as the one above:
    </string>
    <string name="intentFilterCode">
        <![CDATA[
        <intent-filter>
            \n\t<action android:name="android.intent.action.VIEW" />
            \n\t<data android:scheme="http"/>
            \n\t<category android:name="android.intent.category.DEFAULT" />
            \n\t<category android:name="android.intent.category.BROWSABLE" />
        \n</intent-filter>]]>
    </string>
    <string name="iccVulnerabilitiesIntroHeading">
        ICC Vulnerabilities and Attacks
    </string>
    <string name="iccVulnerabilitiesIntroText">
        Android ICC can be exploited by attackers and be used to circumvent permission requirements.
        Most of the vulnerabilities shown in this software happen due to the misuse of implicit
        intents or intent filters.

        \n\nSince implicit intents do not directly state what component they target, it is possible
        that an intent is delivered to a malicious app.

        \n\nAdding an intent filter to a component
        exports it by default, making it accessible to other apps. An attacker can create
        malicious intents that can launch other components in ways that may compromise the victim app.

        \n\nThis app focuses on attacks on exported components. A component that is not exported
        can not be accessed by another app, unless that app has the same user ID as component’s app.
    </string>
    <string name="intentHijackingHeading">Intent Hijacking</string>
    <string name="intentHijackingText">
        The Android documentation recommends that explicit intents are used for intra-app
        communication, and implicit intents for inter-application communication. However, developers
        sometimes use implicit intents to start a component within the same app. An attacker can
        make an application with an intent filter designed to match with those implicit intents,
        which can direct them to the malicious application.

        \n\nWhen receiving an intent, a component can read all of its data. Therefore, even if the
        implicit intent is meant for external use, if the developer puts sensitive information in
        it, that data could be intercepted.
    </string>
    <string name="intentSpoofingHeading">Intent Spoofing</string>
    <string name="intentSpoofingText">
        Intent Spoofing attacks happen when a victim component is unexpectedly activated by an
        attacking component using a specially crafted Intent.

        \n\nOften, this attack targets components that are not meant to be accessible outside of
        their apps, but because they have an intent filter and the &lt;exported> tag is not set,
        they are exported automatically. The developers are usually unaware of this. Because the
        component is exported, the attacker can create an explicit intent targeting
        it and does not need to deal with intent filters.

        \n\nThis attack is dangerous because components often extract information from the intents
        they receive. An Intent Spoofing attack could insert malicious information into the victim
        component. The attacker could crash the victim’s app (a DoS attack) or corrupt the user’s
        data. Often, the launch of an activity, service or broadcast
        receiver leads a change in the app’s state, even if the victim component takes no input
        from the intent. And since activities and services can return information to the component
        that activated them, they could leak sensitive information.

        \n\nThis attack is often done against components that were not meant to accessible by other
        apps, and these components are thus less likely to check the input data or make sure they
        do not return private data.

        \n\nDevelopers can secure their application from these attacks in a number of ways. First,
        they should not declare intent filters for internal components, and they should use explicit
        intents to launch them. Secondly, if they need to use intent filters for internal components,
        they should explicitly declare them as not exported in the manifest. Thirdly, they can
        protect components permissions. Fourthly, state-changing operations should not be done in
        exported components. And finally, developers should make sure that exported components do
        not return information that should be private.
    </string>

    <!--Strings for bottom navigation view of main activity-->
    <string name="introButtonText">
        Introduction
    </string>
    <string name="infoButtonText">
        Info
    </string>
    <string name="challengesButtonText">
        Challenges
    </string>

    <!--Strings for bottom navigation view of challenges activity-->
    <string name="manifestsButtonText">Manifests</string>
    <string name="questionsButtonText">Questions</string>

    <!--Strings for other menu stuff-->
    <string name="settingsButtonDescription">Settings</string>

    <string name="broadcastTheftName">Broadcast Theft</string>
    <string name="broadcastTheftDOSName">Broadcast Theft - DOS</string>
    <string name="broadcastTheftMITMName">Broadcast Theft - MITM</string>
    <string name="activityHijackName">Activity Hijack</string>
    <string name="activityHijackResultName">Activity Hijack with result injection</string>
    <string name="serviceHijackName">Service Hijack</string>
    <string name="providerHijackName">Content Provider URI Hijack</string>
    <string name="broadcastInjectionName">Malicious Broadcast Injection</string>
    <string name="activityLaunchName">Malicious Activity Launch</string>
    <string name="serviceLaunchName">Malicious Service Launch</string>
    <string name="permissionAvoidanceName">Permission Avoidance</string>
    <string name="appCollusionName">App collusion</string>
    <string-array name="challenges">
        <item>@string/broadcastTheftName</item>
        <item>@string/broadcastTheftDOSName</item>
        <item>@string/broadcastTheftMITMName</item>
        <item>@string/activityHijackName</item>
        <item>@string/activityHijackResultName</item>
        <item>@string/serviceHijackName</item>
        <item>@string/providerHijackName</item>
        <item>@string/broadcastInjectionName</item>
        <item>@string/activityLaunchName</item>
        <item>@string/serviceLaunchName</item>
        <item>@string/permissionAvoidanceName</item>
        <item>@string/appCollusionName</item>
    </string-array>

    <!--security level names-->
    <string name="lowSecurityLevel">Low</string>
    <string name="mediumSecurityLevel">Medium</string>
    <string name="highSecurityLevel">High</string>
    <string name="veryHighSecurityLevel">Very High</string>
    <string name="impossibleSecurityLevel">Impossible</string>

    <!--security level descriptions-->
    <string name="broadcastTheftLow">
        Broadcasts meant for intra-app use are sent without permission protection and by using
        Context.sendBroadcast().
    </string>
    <string name="broadcastTheftMedium">
        Broadcast for intra-app use is protected by a custom permission and sent using
        Context.sendBroadcast. However, the permission is normal and can be easily gained by the
        malware.
    </string>
    <string name="broadcastTheftHigh">
        Broadcast for intr-app use is protected by a custom permission and is sent using
        Context.sendBroadcast. This permission is dangerous, but a careless user might still grant
        it.
    </string>
    <string name="broadcastTheftVeryHigh">
        Broadcast for intr-app use is protected by a signature permission is sent using
        Context.sendBroadcast. If the attacker gets the certificate of the developer, they can get
        this permission.
    </string>
    <string name="broadcastTheftImpossible">
        Broadcasts are sent using LocalBroadcastManager, or an equivalent, since
        LocalBroadcastManager is deprecated. Alternatively, address the broadcast to the receiver
        inside your app explicitly. Or restrict broadcast to receivers of a certain package.
    </string>

    <!--attack explanations-->
    <string name="broadcastTheftExplanation">
        When a broadcast is sent, the sender does not receive any indication of what components have
        received that broadcast, and receivers can read all the data inside the broadcast intent.

        \n\nTherefore, a malicious app could register a broadcast receiver with as many intent
        filters as possible to receive the maximum number of broadcasts. The malware would be able
        to read the data in the broadcast without the user knowing it. If the app has the permission
        to access the internet, it could be used as spyware.

        \n\nBesides intercepting information meant to be public, it could read sensitive data
        mistakenly placed in a public broadcast by an app. Moreover, if an implicit intent is used
        for a broadcast meant for an app\’s internal use, that broadcast will be sent to any receiver
        on the device with a matching filter. Sensitive user information could thus be intercepted
        and sent to the attacker.

        \n\nThe use of ordered implicit broadcasts can not only enable eavesdropping, but denial of
        service and man in the middle attacks as well.

        \n\nOrdered broadcasts are sent to receivers one at a time. A malicious app could register a
        broadcast receiver with a very high priority to
        ensure it is the first to receive it. It could extract the data from the broadcast, and
        then abort the broadcast, ensuring the intended receivers do not get it and thus perform a
        Denial of Service attack.

        \n\nOtherwise, the malicious receiver could propagate the broadcast with malicious data
        replacing the original one. This could be used to corrupt data or crash other applications.

        \n\nWhen making a broadcast, the developer can specify the permission that a broadcast
        receiver needs to have to receive the intent. This can be used to guard against
        Broadcast Theft. But the malware could still get the permission. Even if the permission is a
        Signature one, the attacker could get it if they have stolen the developer\'s certificate.
        Other ways for a developer to guard against these attacks is to not put sensitive
        information in a broadcast unless necessary, to use explicit broadcasts for intra-app
        use or to send broadcast using LocalBroadcastManager.
    </string>

    <!--scenario explanations-->
    <string name="broadcastTheftScenarioExplanation">
        sdkjhfhsjfwjefpwfkl
    </string>

    <!--flags to be found by the user-->
    <string name="impossibleFlag">Can\'t touch this!</string>
    <string-array name="broadcastTheftFlags">
        <item>Alea iacta est</item>
        <item>Veni, vidi, vici</item>
        <item>Et tu, Brute?</item>
        <item>Galia est omnis divisa in partes tres</item>
    </string-array>

    <!--api requirements-->
    <string name="broadcastTheftAPIRequirements">
        Some broadcast have been introduced in recent API versions.
    </string>

    <!-- questions-->
    <string name="vulnerableAppQuestion">
        What is the vulnerable app for %1s ?
    </string>
    <string name="malwareQuestion">
        What is the malware for %1s ?
    </string>
    <string name="securityLowQuestion">
        What is the flag when vulnerable app is in security level low ?
    </string>
    <string name="securityMediumQuestion">
        What is the flag when vulnerable app is in security level medium ?
    </string>
    <string name="securityHighQuestion">
        What is the flag when vulnerable app is in security level high ?
    </string>
    <string name="securityVeryHighQuestion">
        What is the flag when vulnerable app is in security level very high ?
    </string>

    <!--names for challenge operation modes-->
    <string name="beginnerMode">Beginner Mode</string>
    <string name="expertMode">Expert Mode</string>
    <string name="makeOwnMalwareMode">Make your own Malware Mode</string>
    <string name="fixVulnerableAppMode">Fix Vulnerable App Mode</string>

    <string name="callLogAppName">Call Log</string>
    <string name="newsAggregatorAppName">News Aggregator</string>

    <string name="vulnerableAppHint">Vulnerable app</string>
    <string name="malwareAppHint">Malware</string>
    <string name="flagHint">Flag</string>
    <string name="submitButtonText">Submit</string>
    <string name="wrongAnswer">Wrong answer!</string>
    <string name="completed">Completed</string>

    <string name="operationModes">Operation mode for the challenge:</string>
    <string name="vulnerableAppSecurityLevels">Security Level of vulnerable app:</string>
    <string name="malwareSecurityLevels">Security Level of malware:</string>
    <string name="securityLevelWarning">
        Some security levels may be disabled because the current
        challenge has fewer security levels
    </string>
    <string name="challengeSettingsActivityTitle">Challenge Settings</string>
    <string name="applyText">Apply</string>
    <string name="fileStoragePermissionWarning">
        App needs file storage access to make security level setting accessible to other apps!
    </string>
</resources>