<resources>
    <string name="app_name">Damn Vulnerable Mobile ICC</string>

    <!--Strings for the Information fragment-->
    <string name="welcome_msg">Welcome to DVM-ICC!</string>
    <string name="introductionHeading">Introduction</string>
    <string name="introduction">
        Damn Vulnerable Mobile -  Inter Component Communication is an intentionally insecure
        Android image, created to be an educational tool to teach people about cyberattacks and
        vulnerabilities related to Inter Component Communication (ICC) in Android.

        \n\nThis educational tool is aimed at penetration testers, app developers and tech savvy
        people alike. It has four different operation modes that can be used to complete
        challenges, tailored to users with more or less experience.

        \n\nIndividual vulnerabilities are explored through challenges. Each challenge
        consists of an authentic scenario of a malware attacking a vulnerable application. You
        have to identify the malware and vulnerable apps, then start the apps and use the malware
        to perform an attack and observe its effects.

        \n\nDepending on the user mode, you will benefit from an explanation of the vulnerability,
        how to identify it and of various ways to fix it. You are able to see the attack happen
        and you have to answer various questions to complete the challenge.
    </string>
    <string name="whyICCHeading">Importance of ICC</string>
    <string name="whyICC">
        We chose to explore Inter Component Communication vulnerabilities on Android in this project
        due to the current state of mobile application security.

        \n\nFirstly, insecure inter-component communication is a high-risk vulnerability, and it is
        more dangerous than insecure storage, insecure transmission of data, inadequate brute force
        protection or other common vulnerabilities, according to this
        <a href="https://www.ptsecurity.com/upload/corporate/ww-en/analytics/Mobile-Application-Vulnerabilities-and-Threats-2019-eng.pdf">2019 report</a>.

        \n\nSecondly, this type of vulnerability is relatively common. It can be found in 29
        percent of mobile apps according, and the average Android application has 1.1 ICC
        vulnerabilities. according the report linked above.

        \n\nThirdly, while the overwhelming majority of vulnerabilities of other types are
        introduced in apps through the use of third-party libraries and rarely through developer
        code, ICC vulnerabilities are different. According to <a href ="https://ieeexplore.ieee.org/abstract/document/8936901">this paper</a>
        , between a third and a half of ICC vulnerabilities come from developer code. Therefore,
        education about ICC vulnerabilities addressed to developers would lead to less
        vulnerabilities of this type.

        \n\nFourthly, ICC vulnerabilities are not showcased in detail in real word projects
        similar to ours. Damn Vulnerable Web Application does not cover any Inter Process
        vulnerabilities and TryHackMe.com has no dedicated activities on this topic. Damn Insecure
        and Vulnerable App has 2 challenges that exploit badly implemented communication
        between components. However, they do not show in detail all the possible ICC vulnerabilities
        and threats.
    </string>
    <string name="androidFundamentalsHeader">Android Security Fundamentals</string>
    <string name="androidFundamentals">
        In Android, each application is assigned a unique user ID known only by the OS. The files
        of an app can only be accessed by a user with the same ID as that of the app. Moreover,
        each app runs in its own process by default, and each process runs in its own virtual
        machine. Therefore, each Android app has its own sandbox, which
        enhances the security of the system, as apps are separated from each other.
    </string>
    <string name="apiLevelsHeader">API Levels</string>
    <string name="apiLevels">
        Code written by mobile app developers can interact with the Android system through its
        Application Programming Interface, or API. This API is made up of various packages, classes
        and XML elements that are used to define UI elements, access system resources, define
        application security, and more.

        \n\nThroughout the development of Android,
        the API is modified to introduce new features and improve security or performance. Therefore,
        in order to identify each incremental version of the API, a unique integer is assigned to
        each version or level. This level is independent of the version of the Android release, as
        the API level is solely concerned with modifications in the API and not backend code.

        \n\nHowever, in practice, each Android release usually comes with a new API level. Over the
        years, there have been changes to the API that improved software security, and therefore
        some vulnerabilities are harder or impossible to exploit in current API levels.

        \n\nThe suite of apps developed as part of this project are designed to run on API 25, or
        Android 7.1. They can still run on newer devices, but some vulnerabilities, particularly
        broadcast theft and broadcast injection, are limited on Android 8 and newer.
    </string>
    <string name="androidComponentsHeader">Android Components</string>
    <string name="androidComponents">
        Android mobile applications are made up of logical building blocks called components. In
        Android, a component is an entity which allows the user or the operating system to access
        the application. Therefore, a component does not necessarily correlate
        with other computing concepts such as processes, threads, and classes. When any component
        of an app needs to be run, the system starts a process for that app.

        \n\nThere are four types of components in Android: activities, services, broadcast receivers
        and content providers.
    </string>
    <string name="androidManifestHeading">Android Manifest</string>
    <string name="androidManifestText">
        The manifest of an Android application is an XML file that gives the OS information
        about the app’s structure, capabilities and needs. All Android app components, except
        broadcast receivers, need to be declared in the manifest file, and for each component you
        can define permission requirements and the capabilities of the component.

        \n\nMoreover, the developer must say in the manifest file what hardware or software system
        features the app uses, whether those features are required, and what is the minimum API
        level that the app can run on. For example, an app would not be installed on a device if
        the app’s manifest said it required a microphone and the mobile device did not have
        a microphone.
    </string>
    <string name="activitiesHeading">Activities</string>
    <string name="activitiesText">
        Activities represent the individual app UI screens through which you interact with the app.
        For example, a news aggregator application might have an activity for viewing a list of
        news articles and another for changing the app’s notification settings.

        \n\nActivities are used by the operating system to keep track of what the you see on screen,
        of what information you are interested in, and of minimized apps.

        \n\nActivities are independent components and therefore it is possible that activities of
        different apps collaborate. This is what happens in a browser when you want to share
        a link and you have to choose between various messaging applications.
    </string>
    <string name="servicesHeading">Services</string>
    <string name="servicesText">
        Services are components used for running more long-term operations in the background.
        A service does not represent a separate process or thread, but an interface for the system
        to let the app work in the background. A service does not have a UI by itself.

        \n\nExamples of the usage of services include VPN apps that maintain a VPN connection in
        the background or when WhatsApp performs periodical backups of messages.

        \n\nThere are three types of services: foreground services, which perform tasks that are
        noticeable to the user and must display a notification, background services, which do
        things that are not noticeable by the user, and bound services, which act as servers
        responding to requests made by client components.
    </string>
    <string name="receiverHeading">Broadcast Receivers</string>
    <string name="receiverText">
        Broadcast receivers are components that an app uses to receive system wide broadcasts.
        These broadcasts are messages sent by the operating system or by other apps. Using
        receivers, applications can react to various events. A receiver can
        listen for an event even when the app is not running.

        \n\nFor example, the system can send a broadcast letting apps know that the device’s
        battery is low or that airplane mode has been activated, or an application can send a
        message that the download of a file has finished, and it can be accessed now.

        \n\nUsually, broadcast receivers do a minimal amount of work and simply start other
        components like activities or services to handle the event. Broadcast receivers do not have
        a user interface, but can display notifications. In addition, it is worth noting that they
        do not have to be declared in the manifest file but can be created programmatically as well.

        \n\nThere are three types of broadcasts:
            \n\n• Normal broadcasts – These are sent to all receivers at the same time, and each receiver can react independently of other receivers.
            \n\n• Ordered broadcasts – These are sent to receivers one by one. Unlike normal broadcast,
        the receiver currently processing the broadcast can change what information the broadcast
        contains, and can even cancel the broadcast. Broadcast receivers can be registered with a
        certain priority for getting broadcasts. Receivers with the same priority get broadcasts
        in random order.
            \n\n• Sticky broadcasts – Broadcasts of this type are persistent, as they remain after
        they have been broadcast to all receivers and are re-broadcast to any newly created
        receivers. They have been deprecated since API level 21, because they are very insecure,
        and will not be covered by this project.
    </string>
    <string name="providerHeading">Content Providers</string>
    <string name="providerText">
        Content providers are interfaces through which apps can access data stored in persistent
        storage such as a remote server, an SQLite database or local file storage. A provider can
        be used by components of other apps. Therefore, they are used by the system to manage
        access to shared data. Content providers can restrict access to the data to apps with
        certain permissions and give temporary access to certain files only.
    </string>
    <string name="permissionsHeading">Android Permissions</string>
    <string name="permissionsText">
        Android follows the principle of least privilege. This means that, by default, each app
        only has access to the resources that it needs to complete its job, and cannot perform any
        action that could affect other apps, the OS or the user.

        \n\nThis principle is enforced through a system of permissions, meaning that an application
        can only access sensitive data, system features or components of other applications if it
        possesses the necessary requirements. For instance, an application needs the correct
        permission if it wants to access the user’s contacts or the device’s camera or file system.

        \n\nThe developer can protect the components of an app with permission requirements by
        adding an android:permission tag in the manifest file. These elements can be added once
        for the whole application, or for each component.

        \n\nThere are four types of permissions, based on the level of protection they allow:
            \n\n• Normal permissions – Permissions for access to resources that, if granted, would
                pose a minimal risk to the user, such as the permission to set the time zone.
                They are given automatically.
            \n\n• Dangerous permissions – These permissions are for resources related to private
                user information, or that can affect the state of the system or of other apps.
                The user needs to give these permissions explicitly. Examples include permissions
                to access the camera or the device location.
            \n\n• Signature permissions – These are special permissions, designed for use among a
                group of apps created by the same developer, for purposes specific to those apps.
                An app is automatically granted a signature permission only if it is signed by
                the same certificate as the app that defined the permission. In this case, a
                certificate is a unique identification for the developer of the app, like the
                TLS certificates used to verify the authenticity of websites. The certificate
                can be self-signed by the developer.
            \n\n• Signature or System permissions – a deprecated type of permission since API level
                23. It is automatically granted only if the app is signed by the same certificate
                as the app that declared the permission, or if the app is in the system folder.
                Apps in the system folder are pre-installed by the device’s vendor.

        \n\nApplications have the ability to declare their own permissions. These permissions can
        be used to restrict access to components of an application. This is done by declaring a
        permission in the manifest file of the app. This declaration specifies the permission’s
        full name, a label, a description, and the protection level.

        \n\nExample of a custom permission declaration:
    </string>
    <string name="customPermissionsCode">
        <![CDATA[
        <permission
            \n\tandroid:name=\"uk.swansea.ac.uk.alexandru.
            \n\t\ticc_education.permission.BANKING_ACTIVITY\"
            \n\tandroid:label=\"@string/lab _bankingActivity\"
            \n\tandroid:description=\"@string/desc_bankingActivity\"
            \n\tandroid:protectionLevel=\"dangerous\" />]]>
    </string>
    <string name="iccHeading">Inter Component Communication</string>
    <string name="iccText">
        Each Android application runs in its own sandbox, and by default can not see what other
        applications are doing. Sometimes, we need the system to communicate with the apps, and
        applications can enrich the user\'s experience by collaborating.

        \n\nMoreover, an app component can be used by other apps to provide extra
        functionality. For example, a browser lets you select which social media or messaging app
        to use for sharing a link.

        \n\nIntents are a class in the Android API that are used as messages for communication
        between application components. Intents are used to start new activities, start and stop
        services, bind or unbind a component to a service, and they represent the broadcasts that
        are sent to receivers. They are also used for sending results to the caller of an activity.

        \n\nIntents can specify what component to start, what action the component that sends the
        intent wants to accomplish, data in the form of a URI, the MIME type of the URI, and perhaps
        key value pairs created by the parent component of the intent.

        \n\nBy default, application components are not accessible to outside applications through
        intents. However, a component can be exported and thus receive intents from other
        applications. To export a component, you can set the &lt;exported&gt; tag in a component element
        in the app’s manifest to true. However, if the component has an intent filter defined in
        the manifest, the component will be exported by default, unless the exported tag is
        explicitly set to false. Intent Filters will be fully explained later.

        \n\nFurther complicating things, developers can also configure an application to use the
        same Android User ID as other applications created by them. This means these apps can run
        in the same sandbox and in the same process. Therefore, they can access each other’s
        components regardless of the value of the exported tag or the presence of intent filters.
    </string>
    <string name="explicitIntentsHeading">Explicit Intents</string>
    <string name="explicitIntentsText">
        Explicit intents directly specify the application that should receive the intent. This is
        done by setting either the package name of the receiving application, or the full name of
        a component of said app.

        \n\nMaking an intent to be explicit means that only the targeted app or app component can
        receive the intent. Explicit intents are usually used for communication between components
        of the same app.

        \n\nThe most common usage is when you press a button that leads to the a new
        screen. The activity of the new screen should be started by an explicit intent.
    </string>
    <string name="implicitIntentsHeading">Implicit Intents</string>
    <string name="implicitIntentsText">
        Implicit intents do not directly specify what application or component it should be sent to.
        Instead, the Android system decides who to send it to based on the information in the
        intent and what other components have declared they can handle.

        \n\nTo this end, implicit intents may specify a combination of the action the
        recipient should do, some intent categories, a URI data link, or a MIME data type. All
        of these are optional, and the developer has flexibility in how to define the implicit intent.

        \n\nA component defines what intents it can handle by specifying Intent Filters in the
        manifest file. A filter defines what intents a component can handle. A filter can say
        what actions the component can perform, what intent categories it accepts, the MIME data
        types it accepts or the kind of URI resources it can handle. A component may declare
        multiple Intent Filters, and it is recommended that this is done for each task the
        component can do.

        \n\nWhen an implicit intent is sent, the Android System compares its attributes against all
        intent filters of all components of all apps on the device. For the intent to be matched
        with a filter, three tests are performed: the Action test, the Category test, and the Data
        test.

        \n\nIn order to pass the Action test, the Intent’s action must be amongst the actions of
        the filter. It passes the Category Test if all of its categories are found in the
        filter’s declaration, and the Data Test is passed if the data URI or MIME type of the intent
        matches one of the data elements in the filter.

        \n\nIf the component has multiple filters, the intent only needs to match one of them for
        it to be passed to the component.

        \n\nIf only one intent filter is compatible with the implicit intent, the operating system
        will start that filter’s component. However, if there are multiple matches, a dialog will
        be displayed to the user so they can manually select the app to handle the intent.

        \n\nFor example, if there are multiple browsers installed on the mobile device, and within
        an app the user clicks on a web link, they will then see a dialog letting them
        choose what browser to use to open that page. This is because the parent app sent an
        implicit intent, and all browsers had filters that matched with the intent.

        Below you can see Kotlin code for making an implicit intent for opening a web link.
    </string>
    <string name="implicitIntentCode">
        val intent : Intent = Intent(Intent.ACTION_VIEW,
                \n\t\tURI.parse(\"https://www.pexels.com/\"))
        \nstartActivity(intent)
    </string>
    <string name="intentFilterExplanationText">
        An example of an intent filter to match for web link intents such as the one above:
    </string>
    <string name="intentFilterCode">
        <![CDATA[
        <intent-filter>
            \n\t<action android:name="android.intent.action.VIEW" />
            \n\t<data android:scheme="http"/>
            \n\t<category android:name="android.intent.category.DEFAULT" />
            \n\t<category android:name="android.intent.category.BROWSABLE" />
        \n</intent-filter>]]>
    </string>
    <string name="iccVulnerabilitiesIntroHeading">
        ICC Vulnerabilities and Attacks
    </string>
    <string name="iccVulnerabilitiesIntroText">
        Android ICC can be exploited by attackers and be used to circumvent permission requirements.
        Most of the vulnerabilities shown in this software happen due to the misuse of implicit
        intents or intent filters.

        \n\nSince implicit intents do not directly state what component they target, it is possible
        that an intent is delivered to a malicious app.

        \n\nAdding an intent filter to a component
        exports it by default, making it accessible to other apps. An attacker can create
        malicious intents that can launch other components in ways that may compromise the victim app.

        \n\nThis app focuses on attacks on exported components. A component that is not exported
        can not be accessed by another app, unless that app has the same user ID as component’s app.
    </string>
    <string name="intentHijackingHeading">Intent Hijacking</string>
    <string name="intentHijackingText">
        The Android documentation recommends that explicit intents are used for intra-app
        communication, and implicit intents for inter-application communication. However, developers
        sometimes use implicit intents to start a component within the same app. An attacker can
        make an application with an intent filter designed to match with those implicit intents,
        which can direct them to the malicious application.

        \n\nWhen receiving an intent, a component can read all of its data. Therefore, even if the
        implicit intent is meant for external use, if the developer puts sensitive information in
        it, that data could be intercepted.
    </string>
    <string name="intentSpoofingHeading">Intent Spoofing</string>
    <string name="intentSpoofingText">
        Intent Spoofing attacks happen when a victim component is unexpectedly activated by an
        attacking component using a specially crafted Intent.

        \n\nOften, this attack targets components that are not meant to be accessible outside of
        their apps, but because they have an intent filter and the &lt;exported> tag is not set,
        they are exported automatically. The developers are usually unaware of this. Because the
        component is exported, the attacker can create an explicit intent targeting
        it and does not need to deal with intent filters.

        \n\nThis attack is dangerous because components often extract information from the intents
        they receive. An Intent Spoofing attack could insert malicious information into the victim
        component. The attacker could crash the victim’s app (a DoS attack) or corrupt the user’s
        data. Often, the launch of an activity, service or broadcast
        receiver leads a change in the app’s state, even if the victim component takes no input
        from the intent. And since activities and services can return information to the component
        that activated them, they could leak sensitive information.

        \n\nThis attack is often done against components that were not meant to accessible by other
        apps, and these components are thus less likely to check the input data or make sure they
        do not return private data.

        \n\nDevelopers can secure their application from these attacks in a number of ways. First,
        they should not declare intent filters for internal components, and they should use explicit
        intents to launch them. Secondly, if they need to use intent filters for internal components,
        they should explicitly declare them as not exported in the manifest. Thirdly, they can
        protect components permissions. Fourthly, state-changing operations should not be done in
        exported components. And finally, developers should make sure that exported components do
        not return information that should be private.
    </string>

    <!--Strings for bottom navigation view of welcome activity-->
    <string name="infoButtonText">
        Info
    </string>
    <string name="challengesButtonText">
        Challenges
    </string>
</resources>